<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Runtime 存储 · Substrate Developer Hub</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Runtime存储机制可使数据持久地存储在区块链中，并在runtime逻辑中能够被访问。 “存储应该是区块链runtime开发人员最为关注的点之一”， 这种说法不言自明，因为区块链的主要目标之一就是为底层存储状态提供去中心化共识。 此外，设计良好的存储系统可减少网络中节点的负载，从而降低区块链参与者的开销。 Substrate提供了分层的模块化存储API，使runtime开发人员能根据自身情况作出合适的存储决策。 但同时请记住，区块链runtime存储的基本原则是尽可能少的使用链上存储。 本文旨在提供有关Substrate runtime存储接口的相关信息和最佳实践， 如果想知道这些接口如何实现，请参阅 [进阶存储文档](../advanced/storage)。"/><meta name="docsearch:language" content="zh-CN"/><meta property="og:title" content="Runtime 存储 · Substrate Developer Hub"/><meta property="og:type" content="website"/><meta property="og:url" content="https://substrate-developer-hub.github.io//"/><meta property="og:description" content="Runtime存储机制可使数据持久地存储在区块链中，并在runtime逻辑中能够被访问。 “存储应该是区块链runtime开发人员最为关注的点之一”， 这种说法不言自明，因为区块链的主要目标之一就是为底层存储状态提供去中心化共识。 此外，设计良好的存储系统可减少网络中节点的负载，从而降低区块链参与者的开销。 Substrate提供了分层的模块化存储API，使runtime开发人员能根据自身情况作出合适的存储决策。 但同时请记住，区块链runtime存储的基本原则是尽可能少的使用链上存储。 本文旨在提供有关Substrate runtime存储接口的相关信息和最佳实践， 如果想知道这些接口如何实现，请参阅 [进阶存储文档](../advanced/storage)。"/><meta property="og:image" content="https://substrate-developer-hub.github.io/img/substrate-dev-hub-card.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://substrate-developer-hub.github.io/img/substrate-dev-hub-card.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script type="text/javascript" src="/js/load.js"></script><script type="text/javascript" src="/js/redirect-next.js"></script><script type="text/javascript" src="/js/config.js" defer=""></script><script type="text/javascript" src="/js/klaro.min.js" defer=""></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/prism.css"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zh-CN"><img class="logo" src="/img/Substrate-logo.svg" alt="Substrate Developer Hub"/><h2 class="headerTitleWithLogo">Substrate Developer Hub</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/zh-CN/tutorials" target="_self">教程</a></li><li class="siteNavGroupActive"><a href="/docs/zh-CN/" target="_self">知识库</a></li><li class=""><a href="https://substrate.dev/recipes/" target="_self">进阶菜谱</a></li><li class=""><a href="https://substrate.dev/rustdocs/" target="_self">API 文档</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>简体中文</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/knowledgebase/runtime/storage">English</a></li><li><a href="https://crowdin.com/project/substrate-developer-hub" target="_blank" rel="noreferrer noopener">协助翻译</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Runtime</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">开始<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/">总览</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/getting-started/">安装</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/getting-started/windows-users">在 Windows 系统开始</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/getting-started/glossary">词汇表</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">学习 Substrate<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/extrinsics">Extrinsics</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/tx-pool">交易池</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/account-abstractions">账户摘要</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/session-keys">会话密钥</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/weight">交易权重</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/off-chain-features">链下功能</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Runtime<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/">Runtime 总览</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/primitives">Runtime 的基本类型</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/frame">FRAME</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/pallets">Pallets</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/macros">Runtime宏</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/metadata">Runtime 元数据</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/storage">Runtime 存储</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/origin">Runtime 来源</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/execution">Runtime 执行流程</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/events">Runtime事件</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/errors">Runtime 错误</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/fees">交易费用</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/off-chain-workers">链下工作机</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/debugging">调试</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/tests">Runtime 测试</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/randomness">链上随机生成</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/upgrades">Runtime 升级</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">智能合约<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/overview">总览</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/">ink! 智能合约</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/ink-fundamentals">ink! 概念</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/ink-development">ink! 开发</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/evm-pallet">EVM 模块</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/faq">ink! 常问问题</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">整合<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/polkadot-js">Polkadot-JS</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/libraries">客户端库</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/chain-spec">链规范</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/subkey">Subkey 工具</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/memory-profiling">内存分析</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">进阶<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/codec">SCALE 编解码器</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/consensus">共识机制</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/block-import">区块导入过程</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/executor">执行器</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/cryptography">密码学</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/storage">存储</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/ss58-address-format">SS58 地址格式</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">贡献<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/contribute/help-translate">协助翻译</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/substrate-developer-hub/zh-CN" target="_blank" rel="noreferrer noopener">Translate</a><h1 id="__docusaurus" class="postHeaderTitle">Runtime 存储</h1></header><article><div><span><p>Runtime存储机制可使数据持久地存储在区块链中，并在runtime逻辑中能够被访问。 “存储应该是区块链runtime开发人员最为关注的点之一”， 这种说法不言自明，因为区块链的主要目标之一就是为底层存储状态提供去中心化共识。 此外，设计良好的存储系统可减少网络中节点的负载，从而降低区块链参与者的开销。 Substrate提供了分层的模块化存储API，使runtime开发人员能根据自身情况作出合适的存储决策。 但同时请记住，区块链runtime存储的基本原则是尽可能少的使用链上存储。 本文旨在提供有关Substrate runtime存储接口的相关信息和最佳实践， 如果想知道这些接口如何实现，请参阅 <a href="../advanced/storage">进阶存储文档</a>。</p>
<h2><a class="anchor" aria-hidden="true" id="存储项"></a><a href="#存储项" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>存储项</h2>
<p><a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/index.html">FRAME support</a>中的<code>storage</code> 模块使得runtime开发人员可以灵活地访问Substrate的存储API。 只要是<a href="../advanced/codec">Parity SCALE codec</a>编码支持的值都可以传入到存储API中：</p>
<ul>
<li><a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageValue.html">Storage Value</a> - 单一的值</li>
<li><a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageMap.html">Storage Map</a> - 一组键值对哈希映射</li>
<li><a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageDoubleMap.html">Storage Double Map</a> - 实现了两个键的映射，它提供了有效地删除第一个键相同的所有条目的重要功能。</li>
</ul>
<p>存储项类型的选择应取决于runtime使用该值的逻辑方式。</p>
<h3><a class="anchor" aria-hidden="true" id="storage-value"></a><a href="#storage-value" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Storage Value</h3>
<p>如果一个值需要在runtime里被视作为一个整体，则应该选用这种存储项类型，它可以是一个基础类型值、一个<code>结构体</code>，或者是相关项的一个集合。 尽管将相关项包裹在一个共享<code>结构体</code> 中，是减少存储读取次数的绝佳方法(非常重要的考虑因素)，但当这个结构体的大小增长到一定程度时，它的使用成本可能远远超过存储读取次数减少所带来的好处。 Storage values 也可用来存储集合，但runtime开发人员应当非常注意集合的大小。 因为大型集合产生的存储成本就像大型的 <code>结构体</code>一样高。 此外，如果在runtime中迭代大型的列表，可能会导致处理时间超出区块生产时间 - 如果发生这种情况，区块链将停止产生区块，也就相当于区块链停止运行了。</p>
<h4><a class="anchor" aria-hidden="true" id="方法"></a><a href="#方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>方法</h4>
<p>请参阅 Storage Value 的相关文档以获取 <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageValue.html#required-methods"> Storage Values 对外暴露的完整方法列表 </a>。 下面总结了其中一些最重要的方法：</p>
<ul>
<li><a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageValue.html#tymethod.get"><code>get()</code></a> - 从存储中读取值。</li>
<li><a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageValue.html#tymethod.put"><code>put(val)</code></a> - 存储提供的值。</li>
<li><a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageValue.html#tymethod.mutate"><code>mutate(fn)</code></a> - 使用提供的函数修改值。</li>
<li><a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageValue.html#tymethod.take"><code>take()</code></a> - 加载值并把它从存储中移除。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="storage-maps"></a><a href="#storage-maps" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Storage Maps</h3>
<p>映射数据结构非常适合管理随机访问的项目集，但并不适用于管理需要顺序遍历的项目集。 Substrate中的 Storage Maps 通过键值对哈希映射来实现，这是大多数开发人员都熟悉的模式。 为了给予区块链工程师更多的控制权，Substrate允许开发人员选择用于生成map中的key的<a href="#hashing-algorithms">哈希算法</a>。 请参阅<a href="../advanced/storage">进阶存储文档</a>，以了解更多关于如何实现Substrate的存储映射的信息。</p>
<h4><a class="anchor" aria-hidden="true" id="方法-1"></a><a href="#方法-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>方法</h4>
<p><a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageMap.html#required-methods">Storage Maps 暴露了一系列 API</a> 与 Storage Values 的API很类似。</p>
<ul>
<li><code>get</code> - 从存储中查询对应key关联的值。 Docs: <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageMap.html#tymethod.get"><code>StorageMap#get(key)</code></a>, <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageDoubleMap.html#tymethod.get"><code>StorageDoubleMap#get(key1, key2)</code></a></li>
<li><code>insert</code> - 存储提供的值，并与给定键做关联。 Docs: <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageMap.html#tymethod.insert"><code>StorageMap#insert(key, val)</code></a>, <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageDoubleMap.html#tymethod.insert"><code>StorageDoubleMap#insert(key1, key2, val)</code></a></li>
<li><code>mutate</code> - 使用提供的函数来更改与给定键关联的值。 Docs: <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageMap.html#tymethod.mutate"><code>StorageMap#mutate(key, fn)</code></a>, <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageDoubleMap.html#tymethod.mutate"><code>StorageDoubleMap#mutate(key1, key2, fn)</code></a></li>
<li><code>take</code> - 加载与给定键关联的值，并将其从存储中删除。 Docs: <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageMap.html#tymethod.take"><code>StorageMap#take(key)</code></a>, <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageDoubleMap.html#tymethod.take"><code>StorageDoubleMap#take(key1, key2)</code></a></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="iterable-storage-maps"></a><a href="#iterable-storage-maps" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Iterable Storage Maps</h4>
<p>Substrate Storage Maps 可以遍历键和值。 由于映射通常用于存储无大小约束的数据集(例如帐户余额)，如果在runtime中对整个映射进行遍历，很容易超出区块生产时间。 此外，与访问本地列表元素相比，访问映射的元素需要更多数据库读取操作，因此遍历映射的时间明显比遍历列表的时间要&lt;em x-id =“ 4”&gt;多得多</em> 。 这并不是说在runtime中遍历映射是“错误的”。Substrate主要想表达的是&quot;<a href="#best-practices">首要原则</a>&quot;，而不是简单粗暴的对与错。 区块链runtime的高效是Substrate的首要原则之一，这些信息旨在帮助您了解&lt;em x-id =“ 4”&gt;所有</em> Substrate的存储功能，并帮助你在坚持首要原则的基础上使用这些功能。</p>
<h5><a class="anchor" aria-hidden="true" id="iterable-storage-map-methods"></a><a href="#iterable-storage-map-methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Iterable Storage Map Methods</h5>
<p>Substrate的 Iterable Storage Map 接口定义了如下方法。 要注意的是，在 Iterable Storage Double Map 中，<code>iter</code> 和 <code>drain</code>方法要求传入一个参数，即第一个键：</p>
<ul>
<li><code>iter</code> - 不按特定顺序枚举出映射中所有的元素。 如果在遍历映射时同时修改映射，则会返回异常结果。 Docs: <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.IterableStorageMap.html#tymethod.iter"><code>IterableStorageMap#iter()</code></a>, <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.IterableStorageDoubleMap.html#tymethod.iter"><code>IterableStorageDoubleMap#iter(key1)</code></a></li>
<li><code>drain</code> - 从映射中移除所有元素，并以不固定的顺序遍历它们。 如果在运行drain方法时同时给映射增加新元素，则会返回未知结果。 Docs: <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.IterableStorageMap.html#tymethod.drain"><code>IterableStorageMap#drain()</code></a>, <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.IterableStorageDoubleMap.html#tymethod.drain"><code>IterableStorageDoubleMap#drain(key1)</code></a></li>
<li><code>translate</code> - 使用提供的函数并以不特定顺序来转换映射中的所有元素。 如果想从 map 里删除一个元素，则需要在 translation 函数内返回 <code>None</code>。 Docs: <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.IterableStorageMap.html#tymethod.translate"><code>IterableStorageMap#translate(fn)</code></a>, <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.IterableStorageDoubleMap.html#tymethod.translate"><code>IterableStorageDoubleMap#translate(fn)</code></a></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="哈希算法"></a><a href="#哈希算法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>哈希算法</h4>
<p>如上文所述，Substrate Storage Maps 的一个特性是，允许开发人员指定生成map中的key的哈希算法。 用于封装哈希计算逻辑的Rust对象称为&quot;hasher&quot;。 广义上讲，可以用两种方式来描述供Substrate开发人员使用的&quot;hasher&quot;：它们是否是密码学安全的，以及它们是否产生透明的输出。 为了完整起见，下文也会介绍非透明哈希算法的特征。但是请记住，我们不推荐在基于FRAME打造的区块链内使用任何产生不透明输出的哈希算法。</p>
<h5><a class="anchor" aria-hidden="true" id="加密哈希算法"></a><a href="#加密哈希算法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>加密哈希算法</h5>
<p>加密哈希算法的原理，是使用密码学来减少通过控制输入内容以对输出结果施加影响的情况。 举个例子，即使输入只有简单的数字如1-10，加密哈希算法也会产生广泛分布的输出。 因此，在用户能控制存储映射键的情况下，使用加密哈希算法尤其重要。 否则，可能存在潜在的攻击载体，很容易被作恶者利用，来降低区块链网络的性能。 其中一个推荐用加密哈希算法生成映射键的情景，就是用映射追踪用户余额。 这种情景下使用加密哈希算法尤其重要，这样攻击者就无法通过向多个连续帐号进行小额转账来轰炸系统。 而如果没有加密哈希算法，因此产生的不平衡存储结构将会影响系统性能。 但加密哈希算法比非加密哈希算法更复杂且耗费资源更多，这就是为什么Substrate允许开发人员自由选择何时使用它们的原因。</p>
<h5><a class="anchor" aria-hidden="true" id="透明哈希算法"></a><a href="#透明哈希算法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>透明哈希算法</h5>
<p>透明哈希算法是在给定输出结果的情况下，用于挖掘和验证输入内容的简单算法。 Substrate通过将算法的输入与其输出结果相连接，使哈希算法变得透明。 这使得用户可以很容易的获取key对应的原始未哈希的值和通过重新哈希来验证它。 Substrate的核心开发人员在基于FRAME的runtime中，已经<strong>废弃了不透明哈希算法的使用</strong>，此处的内容主要是出于完整性的考虑而呈现。 实际上，如果要获得<a href="#iterable-storage-maps">iterable map</a>的功能，则<em>必须</em>使用透明的哈希算法。 请参阅<a href="../advanced/storage#storage-map-keys">进阶存储文档</a> 以了解更多关于透明哈希算法的重要功能。</p>
<h5><a class="anchor" aria-hidden="true" id="常见的substrate哈希算法"></a><a href="#常见的substrate哈希算法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>常见的Substrate哈希算法</h5>
<p>下表列出了Substrate中使用的一些常见哈希算法，并指出了哪些是加密的和透明的：</p>
<table>
<thead>
<tr><th>Hasher</th><th>密码学安全</th><th>是否透明</th></tr>
</thead>
<tbody>
<tr><td><a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/struct.Blake2_128Concat.html">Blake2 128 Concat</a></td><td>X</td><td>X</td></tr>
<tr><td><a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/struct.Twox64Concat.html">TwoX 64 Concat</a></td><td></td><td>X</td></tr>
<tr><td><a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/struct.Identity.html">Identity</a></td><td></td><td>X</td></tr>
</tbody>
</table>
<p>Identity hasher封装了这样一个哈希算法，该算法的输出等于其输入(identity函数)。 只有当key已经是加密哈希值时，才使用此类型的hasher。</p>
<h2><a class="anchor" aria-hidden="true" id="声明存储项"></a><a href="#声明存储项" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>声明存储项</h2>
<p>可使用<a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/macro.decl_storage.html"><code>decl_storage</code> 宏</a>轻松创建新的runtime存储项。 以下示例可展示了如何声明每种类型的存储项：</p>
<pre><code class="hljs css language-rust"><span class="token macro property">decl_storage!</span> <span class="token punctuation">{</span>
    <span class="token keyword">trait</span> <span class="token class-name">Store</span> <span class="token keyword">for</span> <span class="token class-name">Module</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Trait</span><span class="token operator">></span> <span class="token keyword">as</span> <span class="token class-name">Example</span> <span class="token punctuation">{</span>
        <span class="token class-name">SomePrivateValue</span><span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">;</span>
        <span class="token keyword">pub</span> <span class="token class-name">SomePrimitiveValue</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token function-definition function">some_primitive_value</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">;</span>
        <span class="token comment">// types can make use of the generic `T: Trait`</span>
        <span class="token keyword">pub</span> <span class="token class-name">SomeComplexValue</span><span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">::</span><span class="token class-name">AccountId</span><span class="token punctuation">;</span>
        <span class="token keyword">pub</span> <span class="token class-name">SomeMap</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token function-definition function">some_map</span><span class="token punctuation">)</span><span class="token punctuation">:</span> map <span class="token function">hasher</span><span class="token punctuation">(</span>blake2_128_concat<span class="token punctuation">)</span> <span class="token class-name">T</span><span class="token punctuation">::</span><span class="token class-name">AccountId</span> <span class="token operator">=></span> <span class="token keyword">u32</span><span class="token punctuation">;</span>
        <span class="token keyword">pub</span> <span class="token class-name">SomeDoubleMap</span><span class="token punctuation">:</span> double_map <span class="token function">hasher</span><span class="token punctuation">(</span>blake2_128_concat<span class="token punctuation">)</span> <span class="token keyword">u32</span><span class="token punctuation">,</span> <span class="token function">hasher</span><span class="token punctuation">(</span>blake2_128_concat<span class="token punctuation">)</span> <span class="token class-name">T</span><span class="token punctuation">::</span><span class="token class-name">AccountId</span> <span class="token operator">=></span> <span class="token keyword">u32</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>请注意，映射的存储项指定了将要使用的<a href="#hashing-algorithms">哈希算法</a>。</p>
<h3><a class="anchor" aria-hidden="true" id="可见性"></a><a href="#可见性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>可见性</h3>
<p>在上面的示例中，除了 <code>SomePrivateValue</code> 外的所有存储单元都是通过<code>pub</code>关键字来表明它们是公开可见的。 事实上区块链上的存储在<a href="#accessing-storage-items">runtime_之外_始终是公开可见</a>的； Substrate存储项目的可见性仅影响到runtime_之内_的其他pallet是否能够访问该存储项目。</p>
<h3><a class="anchor" aria-hidden="true" id="getter方法"></a><a href="#getter方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Getter方法</h3>
<p><code>decl_storage</code>宏提供了一个可选的<code>get</code> 扩展，用来实现获取模块内存储项对应存储内容的getter方法；这一扩展接收一个getter函数名作为参数。 如果缺省了这个可选的扩展，你仍然可以获取存储项中的值，只是不能使用模块内定义的getter方法这种方式，而是使用 <a href="#methods">存储项的<code>get</code>方法</a>。 请记住，可选的<code>get</code>扩展仅影响从Substrate代码中访问该存储项的方式； 而通过<a href="../advanced/storage#Querying-Storage">查询runtime存储状态</a>的方式是一直能获取所有存储值的。</p>
<p>以下示例为<code>SomeValue</code>这个 Storage Value 实现了一个名为<code>some_value</code>的getter方法。 现在这个模块除了可通过<code>SomeValue::get()</code>方法来访问存储值以外，还可以通过<code>Self::some_value()</code>这个方法来访问：</p>
<pre><code class="hljs css language-rust"><span class="token macro property">decl_storage!</span> <span class="token punctuation">{</span>
    <span class="token keyword">trait</span> <span class="token class-name">Store</span> <span class="token keyword">for</span> <span class="token class-name">Module</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Trait</span><span class="token operator">></span> <span class="token keyword">as</span> <span class="token class-name">Example</span> <span class="token punctuation">{</span>
        <span class="token keyword">pub</span> <span class="token class-name">SomeValue</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token function-definition function">some_value</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="缺省值"></a><a href="#缺省值" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺省值</h3>
<p>Substrate允许自定义的缺省值，即当存储单元没有设置时所返回的值。 缺省值并&lt;strong x-id =“ 1”&gt;不</strong>占用runtime的实际存储空间，但runtime代码可以使用这个值。</p>
<p>以下示例为映射中的所有条目指定缺省值：</p>
<pre><code class="hljs css language-rust"><span class="token macro property">decl_storage!</span> <span class="token punctuation">{</span>
    <span class="token keyword">trait</span> <span class="token class-name">Store</span> <span class="token keyword">for</span> <span class="token class-name">Module</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Trait</span><span class="token operator">></span> <span class="token keyword">as</span> <span class="token class-name">Example</span> <span class="token punctuation">{</span>
        <span class="token keyword">pub</span> <span class="token class-name">SomeMap</span><span class="token punctuation">:</span> map <span class="token keyword">u64</span> <span class="token operator">=></span> <span class="token keyword">u64</span> <span class="token operator">=</span> <span class="token number">1337</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="创世配置"></a><a href="#创世配置" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>创世配置</h3>
<p>Substrate的runtime存储API提供了在创世区块中初始化存储项的功能。 创世存储配置API对外暴露了许多初始化存储的机制，这些机制在<code>decl_storage</code>宏中都可以定义。 这些机制整体会创建一个 <code>GenesisConfig</code> 数据类型，它实现了接口 <a href="https://substrate.dev/rustdocs/v2.0.0/sp_runtime/trait.BuildModuleGenesisStorage.html">the <code>BuildModuleGenesisStorage</code> trait</a> ，并且它将会被添加到包含此类存储单元的模块里 (比如 <a href="https://substrate.dev/rustdocs/v2.0.0/pallet_balances/struct.GenesisConfig.html"><code>Struct pallet_balances::GenesisConfig</code></a>); 标记为具有创世配置的存储单元，在该数据类型内有一个对应的属性。 为了能够使用模块的创世配置功能，在用&lt;a href =“ https://substrate.dev/rustdocs/v2.0.0/ frame_support/macro.construct_runtime.html“&gt; <code>construct_runtime</code>宏</a>添加相应模块时，必须要把<code>Config</code>元素包含进去。 各个模块的 <code>GenesisConfig</code> 类型会被聚合到整个runtime的 <code>GenesisConfig</code> 类型里，这一类型实现了 <a href="https://substrate.dev/rustdocs/v2.0.0/sp_runtime/trait.BuildStorage.html">the <code>BuildStorage</code> trait</a> (e.g. <a href="https://substrate.dev/rustdocs/v2.0.0/node_template_runtime/struct.GenesisConfig.html"><code>Struct node_template_runtime::GenesisConfig</code></a>); 这一类型的每一个属性对应着runtime某个模块的 <code>GenesisConfig</code>。 最终runtime的 <code>GenesisConfig</code> 被暴露出来，通过 <a href="https://substrate.dev/rustdocs/v2.0.0/sc_chain_spec/trait.ChainSpec.html">the <code>ChainSpec</code> trait</a>. 如果想获取关于使用Substrate的创世存储配置功能的完整示例，请参阅<a href="https://github.com/tetcoin/tetcore/blob/master/frame/society/src/lib.rs">Society pallet</a>中的<code>decl_storage</code>宏以及<a href="https://github.com/tetcoin/tetcore/blob/master/bin/node/cli/src/chain_spec.rs">Substrate代码库随附的链规格文件</a>中的Society pallet存储的创世配置。 请继续阅读以获取有关这些功能的详细说明。</p>
<h4><a class="anchor" aria-hidden="true" id="config"></a><a href="#config" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>config</code></h4>
<p>当使用 <code>decl_storage</code> 宏声明存储项时，可使用一个可选的<code>config</code>扩展名，该扩展名会在pallet的<code>GenesisConfig</code>数据类型中添加一个属性，而属性的值将用作区块链创世区块的存储项初始值。 <code>config</code> 扩展接收一个参数，该参数将作为在<code>GenesisConfig</code>数据类型上的属性名称。 如果同时提供了 <a href="#getter-methods"><code>get</code>扩展</a> ，则此参数是可选的( <code>get</code>函数的名称将用作属性的名称)。</p>
<p>以下示例展示了如何将 <code>config</code> 扩展与名为 <code>MyVal</code>的 Storage Value 一起使用，从而在所在模块的 <code>GenesisConfig</code> 数据类型上创建一个名为 <code>init_val</code>的属性。 随后又演示了如何使用<code>GenesisConfig</code> 类型在区块链的创世区块中设置存储初始值。</p>
<p>在 <code>my_module/src/lib.rs</code>中:</p>
<pre><code class="hljs css language-rust"><span class="token macro property">decl_storage!</span> <span class="token punctuation">{</span>
    <span class="token keyword">trait</span> <span class="token class-name">Store</span> <span class="token keyword">for</span> <span class="token class-name">Module</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Trait</span><span class="token operator">></span> <span class="token keyword">as</span> <span class="token class-name">MyModule</span> <span class="token punctuation">{</span>
        <span class="token keyword">pub</span> <span class="token class-name">MyVal</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token function-definition function">my_val</span><span class="token punctuation">)</span> <span class="token function">config</span><span class="token punctuation">(</span>init_val<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在 <code>chain_spec.rs</code>中:</p>
<pre><code class="hljs css language-rust"><span class="token class-name">GenesisConfig</span> <span class="token punctuation">{</span>
    my_module<span class="token punctuation">:</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">MyModuleConfig</span> <span class="token punctuation">{</span>
        init_val<span class="token punctuation">:</span> <span class="token number">221u64</span> <span class="token operator">+</span> <span class="token constant">SOME_CONSTANT_VALUE</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="build"></a><a href="#build" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>build</code></h4>
<p><code>decl_storage</code>宏的 <a href="#config"><code>config</code>扩展</a> 允许开发者在chain specification文件中配置模块的创始存储状态，而 <code>build</code>扩展则允许开发者在存储单元对应的模块内实现同样的功能 (这种方式可以访问模块的私有函数)。 和<code>config</code>一样，<code>build</code>扩展接受单个参数，不同的是该参数是必需的，而且得是一个闭包，闭包本质上就是一个函数。 调用<code>build</code>闭包时需要传入一个参数，它的类型是本模块的<code>GenesisConfig</code> (这样就能轻松访问<code>GenesisConfig</code>类型的所有属性)。 可以将<code>build</code>扩展和<code>config</code>扩展一起用于单个存储项，在这种情况下，当前pallet的<code>GenesisConfig</code>类型会有一个属性，属性名是由<code>config</code>设置的，属性对应的值在chain specification中设置，但是存储项的初始值是由 <code>build</code> 闭包的返回值确定的。</p>
<p>以下示例展示了如何使用<code>build</code> 设置存储项的初始值。 该示例涉及两个存储项：一个是会员帐户ID的列表，另一个表示此列表中的特殊会员即高级会员。 会员列表由 <code>config</code>扩展提供，而高级会员，假设是会员列表中的第一个元素，我们使用 <code>build</code>扩展设置。</p>
<p>在 <code>my_module/src/lib.rs</code>中:</p>
<pre><code class="hljs css language-rust"><span class="token macro property">decl_storage!</span> <span class="token punctuation">{</span>
    <span class="token keyword">trait</span> <span class="token class-name">Store</span> <span class="token keyword">for</span> <span class="token class-name">Module</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Trait</span><span class="token operator">></span> <span class="token keyword">as</span> <span class="token class-name">MyModule</span> <span class="token punctuation">{</span>
        <span class="token keyword">pub</span> <span class="token class-name">Members</span> <span class="token function">config</span><span class="token punctuation">(</span>orig_ids<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">::</span><span class="token class-name">AccountId</span><span class="token operator">></span><span class="token punctuation">;</span>
        <span class="token keyword">pub</span> <span class="token class-name">Prime</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>config<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">GenesisConfig</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span><span class="token closure-punctuation punctuation">|</span></span> config<span class="token punctuation">.</span>orig_ids<span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cloned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">::</span><span class="token class-name">AccountId</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在 <code>chain_spec.rs</code>中:</p>
<pre><code class="hljs css language-rust"><span class="token class-name">GenesisConfig</span> <span class="token punctuation">{</span>
    my_module<span class="token punctuation">:</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">MyModuleConfig</span> <span class="token punctuation">{</span>
        orig_ids<span class="token punctuation">:</span> <span class="token constant">LIST_OF_IDS</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="add_extra_genesis"></a><a href="#add_extra_genesis" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>add_extra_genesis</code></h4>
<p><code>decl_storage</code>宏的 <code>add_extra_genesis</code>扩展定义了一个可同时使用<a href="#config"><code>config</code></a>和 <a href="#build"><code>build</code></a>扩展且无需将它们与特定存储项做绑定的作用域。 可在 <code>add_extra_genesis</code>作用域内通过 <code>config</code> 来向当前pallet的<code>GenesisConfig</code> 数据类型添加一个属性，该属性可以在任意<code>build</code> 闭包中使用。 在 <code>add_extra_genesis</code>作用域内定义的<code>build</code> 闭包可用于执行逻辑而无需将该逻辑的返回值与特定存储项的值进行绑定。如果希望在模块内调用私有帮助函数来设置多个存储项，或者在本模块中调用其他模块上定义的功能，都适合采用这种用法。</p>
<p>以下使用之前的案例来展示 <code>build</code>扩展的用法：一个维护会员帐户ID列表以及指定高级会员的模块。 在案例中，<code>add_extra_genesis</code>扩展定义了一个<code>GenesisConfig</code> 属性，这个属性并未绑定到特定存储项。除此之外，该扩展还定义了一个<code>build</code>闭包，用于本模块内调用私有函数以设置多个存储项值。 鉴于本示例的目的，私有帮助函数(<code>initialize_members</code>) 的实现留给大家想象。</p>
<p>在 <code>my_module/src/lib.rs</code>中:</p>
<pre><code class="hljs css language-js">decl_storage! {
    trait Store <span class="hljs-keyword">for</span> Module&lt;T: Trait&gt; <span class="hljs-keyword">as</span> MyModule {
        pub Members: Vec&lt;T::AccountId&gt;;
        pub Prime: T::AccountId;
    }
    add_extra_genesis {
        config(orig_ids): Vec&lt;T::AccountId&gt;;
        build(|config| Module::<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>::initialize_members(&amp;config.members))
    }
}
</span></code></pre>
<p>在 <code>chain_spec.rs</code>中:</p>
<pre><code class="hljs css language-rust"><span class="token class-name">GenesisConfig</span> <span class="token punctuation">{</span>
    my_module<span class="token punctuation">:</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">MyModuleConfig</span> <span class="token punctuation">{</span>
        orig_ids<span class="token punctuation">:</span> <span class="token constant">LIST_OF_IDS</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="访问存储项"></a><a href="#访问存储项" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>访问存储项</h2>
<p>基于Substrate构建的区块链对外暴露了一个远程过程调用(RPC) 服务，该服务可用于查询区块链的链上存储。 可使用<a href="https://polkadot.js.org/">Polkadot JS</a>之类的软件库，用代码轻松地与RPC服务器进行交互并访问存储项。 Polkadot JS团队还维护着<a href="https://polkadot.js.org/apps">Polkadot Apps UI</a>，这是一个功能齐全的Web应用程序，用于与基于Substrate的区块链进行交互和查询存储。 请参阅<a href="../advanced/storage">进阶存储文档</a>，以了解Substrate如何使用键值对数据库来实现不同类型的存储项，以及如何通过RPC服务器直接查询此数据库。</p>
<h2><a class="anchor" aria-hidden="true" id="最佳实践"></a><a href="#最佳实践" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>最佳实践</h2>
<p>Substrate的目标是提供一个灵活的框架，使人们可以构建适合其需求的区块链，Substrate的核心开发者有意不以“对”或“错”的角度来思考如何构建区块链。 这意味着，Substrate代码库遵循许多最佳实践，以长期促进安全、高效且可维护的区块链网络的建设。 以下各节概述了使用Substrate存储的最佳实践，并描述了推动它们发展的首要原则。</p>
<h3><a class="anchor" aria-hidden="true" id="存储什么"></a><a href="#存储什么" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>存储什么</h3>
<p>请记住，区块链runtime存储的基本原则是最大程度地减少链上空间的使用。 仅<em>对共识强依赖</em>的数据才应存储在runtime中。 如果可以，请尽可能使用如元数据哈希之后的结果来减少存储的数据量。 例如，许多Substrate治理相关的功能 (e.g. <a href="https://substrate.dev/rustdocs/v2.0.0/pallet_democracy/enum.Call.html#variant.propose"> Democracy pallet 的 <code>propose</code>可调用函数</a>) 允许网络参与者对可调用函数的 <em>哈希</em>进行投票，哈希值大小是有界的，但函数本身内容大小可能是无界的。 其中一种场景就是对Runtime进行升级时，可调用函数需要接收整个runtime Wasm数据块作为其参数。 由于这些治理机制是 <em>在链上</em>实现的，因此，就给定提案的状态达成共识所需的所有信息也必须在链上存储-包括投票的 <em>内容</em>。 然而，Substrate的治理机制通过将链上提案与其哈希值进行绑定的方式，巧妙地把提案相关所有数据上链的时间，推迟到了提案通过<em>之后</em>。 这意味着存储空间不会浪费在未通过的提案上。 一旦提案通过以后，相关人员就会对实际的可调用函数本身(连同其所有参数) 进行重新哈希，并与提案中的哈希值做比较，确认无误后便可发起调用。 另一种常见的使用哈希来最小化链上存储数据的模式，是在 <a href="https://ipfs.io/">IPFS</a>中存储元数据，这意味着只需在链上存储IPFS地址 (有界的哈希值) 就可以了。</p>
<p>哈希只是其中一种用于控制runtime存储大小的机制， 另一种控制机制的例子是 <a href="#create-bounds">边界</a>。</p>
<h3><a class="anchor" aria-hidden="true" id="先验证，后写入"></a><a href="#先验证，后写入" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>先验证，后写入</h3>
<p>Substrate不会对发送交易之前的状态进行缓存， 而是在调用时直接把更改应用到链上去。 因此，如果交易失败，任何状态的更改都会保留下来。 由于这个原因，在确定已满足所有前提条件之前，请勿进行任何存储更改。 一般而言，用于修改存储的代码块应该构造如下：</p>
<pre><code class="hljs css language-rust"><span class="token punctuation">{</span>
  <span class="token comment">// all checks and throwing code go here</span>

  <span class="token comment">// ** no throwing code below this line **</span>

  <span class="token comment">// all event emissions &amp; storage writes go here</span>
<span class="token punctuation">}</span>
</code></pre>
<p>不要用runtime存储来记录原子性操作的中间数据或瞬态数据，或者操作失败时不再需要的数据。 这并不意味着不能使用runtim存储来跟踪需要多个原子操作才能完成的动作，例如 <a href="https://substrate.dev/rustdocs/v2.0.0/pallet_utility/enum.Call.html#variant.as_multi">Utility pallet的多重签名功能</a>。 在这个例子中，即便给定的函数调用可能永远都不会搜集到足够的签名以被实际发起，runtime存储也可用来跟踪可调用函数获取的签名。 案例中的每个签名都被视为多重签名操作中一个原子事件；只有满足与该签名相关的所有前提条件后，签名的数据才会被记录下来。</p>
<h3><a class="anchor" aria-hidden="true" id="创建边界"></a><a href="#创建边界" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>创建边界</h3>
<p>约束存储项的大小在控制runtime存储的使用中非常有效，因此在整个Substrate代码库中多次重复使用了这种方法。 一般而言，任何由用户操作产生的存储项都应设置边界。 <a href="https://substrate.dev/rustdocs/v2.0.0/pallet_utility/trait.Trait.html#associatedtype.MaxSignatories">Utility pallet的多重签名功能</a>就是其中一个例子。 在这个例子中，与多重签名操作相关的签名者列表是由多重签名参与者提供的。 要使多重签名操作的状态<a href="#what-to-store">达成共识</a>，必须得使用此签名者列表，因此也必然要将其存储在runtime中。 但是，为了使runtime开发人员能够控制这些列表最大能占用的存储空间，Utility pallet要求用户配置一个边界数字，该约束将作为写入存储的<a href="#verify-first-write-last">前提条件</a>进行检查。</p>
<h2><a class="anchor" aria-hidden="true" id="后续步骤"></a><a href="#后续步骤" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>后续步骤</h2>
<h3><a class="anchor" aria-hidden="true" id="进一步学习"></a><a href="#进一步学习" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>进一步学习</h3>
<p>参阅<a href="../advanced/storage">进阶存储文档</a>。</p>
<h3><a class="anchor" aria-hidden="true" id="例子"></a><a href="#例子" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>例子</h3>
<p>查看Substrate Recipes中关于存储的不同主题示例：</p>
<ul>
<li><a href="https://substrate.dev/recipes/storage-maps.html">Storage Maps</a>.</li>
<li><a href="https://substrate.dev/recipes/cache.html">Caching Storage Calls</a>.</li>
<li><a href="https://substrate.dev/recipes/vec-set.html">Using Vectors</a>.</li>
<li><a href="https://substrate.dev/recipes/map-set.html">Using Maps</a>.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="参考文档"></a><a href="#参考文档" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参考文档</h3>
<ul>
<li>请翻阅 <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/macro.decl_storage.html"><code>decl_storage!</code> 宏</a> 的参考文档，以获取更多关于可用存储声明的细节。</li>
<li>参阅参考文档 <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageValue.html">StorageValue</a>, <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageMap.html">StorageMap</a> 和 <a href="https://substrate.dev/rustdocs/v2.0.0/frame_support/storage/trait.StorageDoubleMap.html">StorageDoubleMap</a> 来了解它们的API。</li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/zh-CN/knowledgebase/runtime/metadata"><span class="arrow-prev">← </span><span>Runtime 元数据</span></a><a class="docs-next button" href="/docs/zh-CN/knowledgebase/runtime/origin"><span>Runtime 来源</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#存储项">存储项</a><ul class="toc-headings"><li><a href="#storage-value">Storage Value</a></li><li><a href="#storage-maps">Storage Maps</a></li></ul></li><li><a href="#声明存储项">声明存储项</a><ul class="toc-headings"><li><a href="#可见性">可见性</a></li><li><a href="#getter方法">Getter方法</a></li><li><a href="#缺省值">缺省值</a></li><li><a href="#创世配置">创世配置</a></li></ul></li><li><a href="#访问存储项">访问存储项</a></li><li><a href="#最佳实践">最佳实践</a><ul class="toc-headings"><li><a href="#存储什么">存储什么</a></li><li><a href="#先验证，后写入">先验证，后写入</a></li><li><a href="#创建边界">创建边界</a></li></ul></li><li><a href="#后续步骤">后续步骤</a><ul class="toc-headings"><li><a href="#进一步学习">进一步学习</a></li><li><a href="#例子">例子</a></li><li><a href="#参考文档">参考文档</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/Substrate-logo.svg" alt="Substrate Developer Hub" width="66" height="58"/></a><div><h5>开发者中心</h5><a href="/zh-CN/tutorials">教程</a><a href="/docs/zh-CN/">知识库</a><a href="https://substrate.dev/recipes/">进阶菜谱</a><a href="https://substrate.dev/rustdocs">API 文档</a></div><div><h5>社区</h5><a href="/zh-CN/community">社区主页</a><a href="/zh-CN/newsletter">通讯</a><a href="https://app.element.io/#/room/!HzySYSaIhtyWrwiwEV:matrix.org">Substrate 技术聊天室</a><a href="/zh-CN/seminar">Substrate 研讨会</a><a href="http://stackoverflow.com/questions/tagged/substrate" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://twitter.com/ParityTech" target="_blank" rel="noreferrer noopener">推特</a><a href="https://www.meetup.com/parity/" target="_blank" rel="noreferrer noopener">聚会活动</a></div><div><h5>更多</h5><a href="https://www.substrate.io/builders-program/">Substrate Builders 计划</a><a href="https://www.parity.io/blog/">Blog</a><a href="https://github.com/tetcoin/tetcore">Substrate GitHub</a><a href="https://github.com/tetcore/">开发者中心 GitHub</a><a href="https://www.parity.io/privacy/">隐私政策</a><a href="/terms">使用条款</a><a href="#" id="cookie-settings">Cookie 设置<script>
                var cookieSettings = document.getElementById('cookie-settings');
                cookieSettings.onclick = function() {
                  return klaro.show();
                };
              </script></a></div></section><section class="copyright">Copyright © 2021 Parity Technologies</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '5cd09916f4ba4c283b2d45ee7386fc34',
                indexName: 'substrate',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:zh-CN"]}
              });
            </script></body></html>